"""
Dota 2 Real Lobby Bot v2 - –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏ (—É–¥–∞–ª–µ–Ω–∏–µ, —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
- –í—ã–±–æ—Ä –±–æ—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏
- –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è: "wb cup 1", "wb cup 2"
"""

import os
import logging
import random
import string
import json
import time
import threading
import asyncio
import multiprocessing
from multiprocessing import Process, Queue
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dotenv import load_dotenv
import pytz
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger

# Steam –∏ Dota 2
import gevent
from steam.client import SteamClient
from steam.enums import EResult
from dota2.client import Dota2Client
from dota2.enums import DOTA_GameMode, EServerRegion

# Telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

load_dotenv()

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('dota2_real_bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è
(WAITING_LOBBY_COUNT, WAITING_ACCOUNT_DATA, WAITING_START_CODE, 
 WAITING_LOBBY_NAME, WAITING_SELECT_BOTS, WAITING_EDIT_BOT_DATA,
 WAITING_DELETE_CONFIRM, WAITING_GAME_MODE, WAITING_SERIES_TYPE,
 WAITING_MATCH_TEAM1, WAITING_MATCH_TEAM2, WAITING_MATCH_DATE,
 WAITING_MATCH_TIME, WAITING_MATCH_BO, WAITING_MATCH_GAME_MODE,
 WAITING_MATCH_SERIES) = range(16)


def steam_worker_process(username: str, password: str, lobby_name: str, 
                         lobby_password: str, server: str, mode: str, series_type: str,
                         result_queue: Queue, shutdown_event):
    """
    –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ.
    –í—ã–ø–æ–ª–Ω—è–µ—Ç –≤—Ö–æ–¥ –≤ Steam, –∑–∞–ø—É—Å–∫ Dota 2 –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏.
    shutdown_event - –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –ª–æ–±–±–∏ –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º.
    series_type - —Ç–∏–ø —Å–µ—Ä–∏–∏: "bo1", "bo2", "bo3", "bo5"
    –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫:
      - 1v1 Solo Mid: –ø—Ä–∏ 2 –∏–≥—Ä–æ–∫–∞—Ö (1 vs 1)
      - –û—Å—Ç–∞–ª—å–Ω—ã–µ —Ä–µ–∂–∏–º—ã: –ø—Ä–∏ 10 –∏–≥—Ä–æ–∫–∞—Ö (5 vs 5)
    """
    # –ù–ï –∏—Å–ø–æ–ª—å–∑—É–µ–º monkey.patch_all() - —ç—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç RecursionError
    # gevent —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –±–µ–∑ —ç—Ç–æ–≥–æ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ
    
    logging.basicConfig(level=logging.INFO)
    local_logger = logging.getLogger(f"steam_worker_{username}")
    
    try:
        local_logger.info(f"[{username}] –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–ø—É—â–µ–Ω")
        
        # –°–æ–∑–¥–∞–µ–º Steam –∫–ª–∏–µ–Ω—Ç
        steam = SteamClient()
        dota = Dota2Client(steam)
        
        lobby_created = threading.Event()
        lobby_data_container = {'data': None}
        
        def on_dota_ready():
            local_logger.info(f"[{username}] Dota 2 –≥–æ—Ç–æ–≤")
            # –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            local_logger.info(f"[{username}] –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è dota: {dir(dota)}")
        
        def on_lobby_created(lobby):
            local_logger.info(f"[{username}] –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ!")
            lobby_data_container['data'] = lobby
            lobby_created.set()
        
        # –°—á—ë—Ç—á–∏–∫ –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
        player_counts = {'last_count': 0, 'last_radiant': 0, 'last_dire': 0}
        
        def on_lobby_changed(lobby_obj):
            """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –í–°–ï –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ª–æ–±–±–∏ (–∏–≥—Ä–æ–∫–∏, —á–∞—Ç –∏ —Ç.–¥.)"""
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–≥—Ä–æ–∫–æ–≤
                if dota.lobby and hasattr(dota.lobby, 'members'):
                    radiant = sum(1 for m in dota.lobby.members if m.team == 0)
                    dire = sum(1 for m in dota.lobby.members if m.team == 1)
                    total = radiant + dire
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –¢–û–õ–¨–ö–û –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
                    if (total != player_counts['last_count'] or 
                        radiant != player_counts['last_radiant'] or 
                        dire != player_counts['last_dire']):
                        
                        local_logger.info(f"[{username}] üë• –ò–≥—Ä–æ–∫–æ–≤ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å: {total}/10 (Radiant: {radiant}, Dire: {dire})")
                        
                        player_counts['last_count'] = total
                        player_counts['last_radiant'] = radiant
                        player_counts['last_dire'] = dire
                
                # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ –≤ –æ–±—ä–µ–∫—Ç–µ –ª–æ–±–±–∏
                if hasattr(lobby_obj, '__dict__'):
                    lobby_dict = lobby_obj.__dict__
                    # –ò—â–µ–º —á—Ç–æ-—Ç–æ —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å —á–∞—Ç–æ–º
                    chat_fields = [k for k in lobby_dict.keys() if 'chat' in k.lower() or 'message' in k.lower()]
                    if chat_fields:
                        local_logger.info(f"[{username}] üí¨ –ù–∞–π–¥–µ–Ω—ã –ø–æ–ª—è —á–∞—Ç–∞: {chat_fields}")
                        for field in chat_fields:
                            local_logger.info(f"[{username}] üí¨ {field} = {lobby_dict[field]}")
                        
            except Exception as e:
                pass  # –ù–µ —Å–ø–∞–º–∏–º
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è
        dota.on('ready', on_dota_ready)
        dota.on(dota.EVENT_LOBBY_NEW, on_lobby_created)
        dota.on(dota.EVENT_LOBBY_CHANGED, on_lobby_changed)  # –í–ê–ñ–ù–û: –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –í–°–ï –∏–∑–º–µ–Ω–µ–Ω–∏—è
        
        # 1. –í—Ö–æ–¥ –≤ Steam
        local_logger.info(f"[{username}] –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Steam...")
        result = steam.login(username=username, password=password)
        
        if result != EResult.OK:
            local_logger.error(f"[{username}] –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: {result}")
            result_queue.put({'success': False, 'error': f'Login failed: {result}'})
            return
        
        local_logger.info(f"[{username}] –£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥ –≤ Steam")
        
        # 2. –ó–∞–ø—É—Å–∫ Dota 2
        local_logger.info(f"[{username}] –ó–∞–ø—É—Å–∫ Dota 2...")
        dota.launch()
        
        # –ñ–¥–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä—É (–º–∞–∫—Å 60 —Å–µ–∫)
        gevent.sleep(10)  # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
        
        # –í–ê–ñ–ù–û: –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –ª—é–±–æ–µ —Å—Ç–∞—Ä–æ–µ –ª–æ–±–±–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        local_logger.info(f"[{username}] –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö –ª–æ–±–±–∏...")
        try:
            dota.destroy_lobby()
            gevent.sleep(2)  # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ
            local_logger.info(f"[{username}] –°—Ç–∞—Ä–æ–µ –ª–æ–±–±–∏ —É–¥–∞–ª–µ–Ω–æ (–µ—Å–ª–∏ –±—ã–ª–æ)")
        except Exception as e:
            local_logger.info(f"[{username}] –°—Ç–∞—Ä—ã—Ö –ª–æ–±–±–∏ –Ω–µ—Ç –∏–ª–∏ –æ—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {e}")
        
        # 3. –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏
        local_logger.info(f"[{username}] –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏: {lobby_name}")
        
        server_mapping = {
            'Stockholm': 8,  # Stockholm = —Ä–µ–≥–∏–æ–Ω 8 –≤ Dota 2
            'Europe West': EServerRegion.Europe,
            'Russia': EServerRegion.Europe,
            'US East': EServerRegion.USEast,
            'US West': EServerRegion.USWest,
        }
        
        mode_mapping = {
            'Captains Mode': DOTA_GameMode.DOTA_GAMEMODE_CM,
            'All Pick': DOTA_GameMode.DOTA_GAMEMODE_AP,
            'Captains Draft': DOTA_GameMode.DOTA_GAMEMODE_CD,
            'Mid Only': DOTA_GameMode.DOTA_GAMEMODE_MO,
            '1v1 Solo Mid': DOTA_GameMode.DOTA_GAMEMODE_1V1MID,
            'Random Draft': DOTA_GameMode.DOTA_GAMEMODE_RD,
            'Single Draft': DOTA_GameMode.DOTA_GAMEMODE_SD,
        }
        
        # –ú–∞–ø–ø–∏–Ω–≥ —Å–µ—Ä–∏–π –∏–≥—Ä
        series_mapping = {
            'bo1': 0,  # Best of 1 (–æ–¥–Ω–∞ –∏–≥—Ä–∞)
            'bo2': 1,  # Best of 2 (–¥–≤–µ –∏–≥—Ä—ã)
            'bo3': 2,  # Best of 3 (–¥–æ 2 –ø–æ–±–µ–¥)
            'bo5': 3,  # Best of 5 (–¥–æ 3 –ø–æ–±–µ–¥)
        }
        
        server_region = server_mapping.get(server, EServerRegion.Europe)
        game_mode = mode_mapping.get(mode, DOTA_GameMode.DOTA_GAMEMODE_CM)
        series_value = series_mapping.get(series_type.lower(), 0)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–±–±–∏ —Å League ID —Ç—É—Ä–Ω–∏—Ä–∞
        options = {
            'game_name': lobby_name,
            'pass_key': lobby_password,
            'server_region': server_region,
            'game_mode': game_mode,
            'series_type': series_value,  # –°–µ—Ä–∏—è –∏–≥—Ä (bo1, bo2, bo3, bo5)
            'allow_spectating': False,
            'allow_cheats': False,
            'dota_tv_delay': 2,
            'fill_with_bots': False,
            'cm_pick': 1,  # Captains Mode: –ø–æ–¥–±—Ä–æ—Å –º–æ–Ω–µ—Ç–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—Ç–æ—Ä–æ–Ω—ã (–ø—Ä–∞–≤–æ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–±–æ—Ä–∞)
            'radiant_series_wins': 0,
            'dire_series_wins': 0,
            'leagueid': 18390,  # ID —Ç—É—Ä–Ω–∏—Ä–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ª–æ–±–±–∏
        }
        
        # –°–æ–∑–¥–∞–µ–º practice –ª–æ–±–±–∏ —Å —Ç—É—Ä–Ω–∏—Ä–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏)
        local_logger.info(f"[{username}] –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ —Å League ID: 18390...")
        dota.create_practice_lobby(
            password=lobby_password,
            options=options
        )
        
        # –ñ–¥–µ–º —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ (–º–∞–∫—Å 60 —Å–µ–∫)
        local_logger.info(f"[{username}] –û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏...")
        gevent.sleep(2)  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 5 –¥–æ 2 —Å–µ–∫—É–Ω–¥
        
        if lobby_created.wait(timeout=58):
            local_logger.info(f"[{username}] –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ! –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏...")
            
            # –í–ê–ñ–ù–û: –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫ —Å–æ–∑–¥–∞–Ω–Ω–æ–º—É –ª–æ–±–±–∏
            try:
                dota.config_practice_lobby(options=options)
                local_logger.info(f"[{username}] –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã")
                gevent.sleep(1)  # –£–º–µ–Ω—å—à–µ–Ω–æ —Å 2 –¥–æ 1 —Å–µ–∫—É–Ω–¥—ã
            except Exception as e:
                local_logger.warning(f"[{username}] –û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")
            
            # –í–ê–ñ–ù–û: –ó–∞—Ö–æ–¥–∏–º –≤ –∫–∞–Ω–∞–ª —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏ (—Å–ª–æ—Ç 1)
            try:
                dota.join_practice_lobby_broadcast_channel(channel=1)
                local_logger.info(f"[{username}] –ó–∞–Ω—è—Ç —Å–ª–æ—Ç –≤ –∫–∞–Ω–∞–ª–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏")
                gevent.sleep(1)
            except Exception as e:
                local_logger.warning(f"[{username}] –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞ –≤ –∫–∞–Ω–∞–ª: {e}")
            
            local_logger.info(f"[{username}] ‚úÖ –õ–æ–±–±–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ!")
            result_queue.put({
                'success': True,
                'lobby_name': lobby_name,
                'password': lobby_password,
                'account': username,
                'server': server,
                'mode': mode,
                'series_type': series_type
            })
        else:
            local_logger.error(f"[{username}] –¢–∞–π–º–∞—É—Ç —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏")
            result_queue.put({'success': False, 'error': 'Lobby creation timeout'})
        
        # –î–µ—Ä–∂–∏–º –ø—Ä–æ—Ü–µ—Å—Å –∂–∏–≤—ã–º 5 –º–∏–Ω—É—Ç, –∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
        is_1v1 = (mode == '1v1 Solo Mid')
        required_radiant = 1 if is_1v1 else 5
        required_dire = 1 if is_1v1 else 5
        total_required = required_radiant + required_dire
        
        if is_1v1:
            local_logger.info(f"[{username}] üîÑ –õ–æ–±–±–∏ –∞–∫—Ç–∏–≤–Ω–æ, –∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç –ø—Ä–∏ 2 –∏–≥—Ä–æ–∫–∞—Ö (1 vs 1)...")
        else:
            local_logger.info(f"[{username}] üîÑ –õ–æ–±–±–∏ –∞–∫—Ç–∏–≤–Ω–æ, –∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç –ø—Ä–∏ 10 –∏–≥—Ä–æ–∫–∞—Ö (5 vs 5)...")
        
        game_started = False
        players_warned = False  # –§–ª–∞–≥ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ–± –∏–≥—Ä–æ–∫–∞—Ö
        
        # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–æ–±–±–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        lobby_event_count = 0
        def on_lobby_event(message):
            nonlocal lobby_event_count
            lobby_event_count += 1
            local_logger.info(f"[{username}] üîî EVENT_LOBBY_CHANGED #{lobby_event_count}")
        
        dota.on('lobby_changed', on_lobby_event)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã (100 —Ä–∞–∑ = 5 –º–∏–Ω—É—Ç)
        for i in range(100):
            gevent.sleep(3)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É –∑–∞–∫—Ä—ã—Ç–∏—è
            if shutdown_event.is_set():
                local_logger.info(f"[{username}] üõë –ü–æ–ª—É—á–µ–Ω–∞ –∫–æ–º–∞–Ω–¥–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ª–æ–±–±–∏!")
                break
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ª–æ–±–±–∏
            try:
                # –î–ï–ë–ê–ì: –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –≤–æ–æ–±—â–µ –ª–æ–±–±–∏
                if i == 0 or i % 10 == 0:  # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                    local_logger.info(f"[{username}] üîç DEBUG: dota.lobby={'exists' if dota.lobby else 'None'}")
                    if dota.lobby:
                        local_logger.info(f"[{username}] üîç DEBUG: hasattr members={hasattr(dota.lobby, 'members')}")
                        if hasattr(dota.lobby, 'members'):
                            local_logger.info(f"[{username}] üîç DEBUG: len(members)={len(dota.lobby.members)}")
                
                if dota.lobby and hasattr(dota.lobby, 'members'):
                    lobby = dota.lobby
                    
                    # –î–ï–ë–ê–ì: –ª–æ–≥–∏—Ä—É–µ–º –í–°–ï–• —á–ª–µ–Ω–æ–≤ –ª–æ–±–±–∏ –∫–∞–∂–¥—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é –µ—Å–ª–∏ –µ—Å—Ç—å –∏–≥—Ä–æ–∫–∏
                    if len(lobby.members) > 0:
                        local_logger.info(f"[{username}] üîç DEBUG: –ß–ª–µ–Ω–æ–≤ –≤ –ª–æ–±–±–∏: {len(lobby.members)}")
                        for idx, member in enumerate(lobby.members):
                            local_logger.info(f"[{username}]   –ò–≥—Ä–æ–∫ {idx+1}: team={member.team}, slot={member.slot if hasattr(member, 'slot') else '?'}")
                    
                    # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ –≤ –∫–æ–º–∞–Ω–¥–∞—Ö
                    radiant_players = sum(1 for m in lobby.members if m.team == 0)  # 0 = Radiant
                    dire_players = sum(1 for m in lobby.members if m.team == 1)     # 1 = Dire
                    total_players = radiant_players + dire_players
                    
                    # –î–ï–ë–ê–ì: –ª–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–º–∞–Ω–¥
                    if total_players > 0:
                        local_logger.info(f"[{username}] üìä DEBUG: Radiant={radiant_players}, Dire={dire_players}, Total={total_players}/{total_required}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
                    if radiant_players == required_radiant and dire_players == required_dire:
                        if is_1v1:
                            local_logger.info(f"[{username}] ‚úÖ 2 –∏–≥—Ä–æ–∫–∞ –≥–æ—Ç–æ–≤—ã (1 vs 1)! –ó–ê–ü–£–°–ö...")
                        else:
                            local_logger.info(f"[{username}] ‚úÖ 10 –∏–≥—Ä–æ–∫–æ–≤ –≥–æ—Ç–æ–≤—ã (5 vs 5)! –ó–ê–ü–£–°–ö...")
                        
                        gevent.sleep(2)
                        dota.launch_practice_lobby()
                        gevent.sleep(3)
                        local_logger.info(f"[{username}] üéÆ –ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞!")
                        game_started = True
                        break
                    
                    # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–≥—Ä–æ–∫–∏, –Ω–æ –Ω–µ –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ - –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑
                    elif total_players > 0 and not players_warned:
                        local_logger.info(f"[{username}] ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤... ({total_players}/{total_required})")
                        players_warned = True
                        
            except Exception as check_error:
                # –ù–µ —Å–ø–∞–º–∏–º –ª–æ–≥–∞–º–∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–π –ø—Ä–æ–≤–µ—Ä–∫–µ
                pass
        
        # –í–ê–ñ–ù–û: –Ø–≤–Ω–æ —É–¥–∞–ª—è–µ–º –ª–æ–±–±–∏ –ü–ï–†–ï–î –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ–º (–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞)
        if not game_started:
            local_logger.info(f"[{username}] –£–¥–∞–ª–µ–Ω–∏–µ –ª–æ–±–±–∏...")
            try:
                dota.destroy_lobby()
                gevent.sleep(3)  # –î–∞—ë–º –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞–º Valve –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å destroy
                local_logger.info(f"[{username}] ‚úÖ –õ–æ–±–±–∏ —É–¥–∞–ª–µ–Ω–æ")
            except Exception as destroy_error:
                local_logger.warning(f"[{username}] –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ª–æ–±–±–∏: {destroy_error}")
        else:
            local_logger.info(f"[{username}] –ò–≥—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞, –ª–æ–±–±–∏ –Ω–µ —É–¥–∞–ª—è–µ–º")
        
        # –û—Ç–∫–ª—é—á–∞–µ–º—Å—è –æ—Ç Steam
        try:
            dota.leave_practice_lobby()
            gevent.sleep(1)
            steam.disconnect()
            local_logger.info(f"[{username}] –û—Ç–∫–ª—é—á–∏–ª–∏—Å—å –æ—Ç Steam")
        except Exception as disconnect_error:
            local_logger.warning(f"[{username}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏: {disconnect_error}")
        
    except Exception as e:
        local_logger.error(f"[{username}] –û—à–∏–±–∫–∞: {e}", exc_info=True)
        result_queue.put({'success': False, 'error': str(e)})


class DotaBot:
    """–ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–¥–Ω–∏–º Steam –∞–∫–∫–∞—É–Ω—Ç–æ–º"""
    
    def __init__(self, username: str, password: str):
        self.username = username
        self.password = password
        self.is_logged_in = False
        self.current_lobby = None
        
        # Steam –∫–ª–∏–µ–Ω—Ç
        self.steam = SteamClient()
        self.dota = Dota2Client(self.steam)
        
        # –°–æ–±—ã—Ç–∏—è
        self.steam.on('logged_on', self._handle_logged_on)
        self.steam.on('disconnected', self._handle_disconnected)
        self.dota.on('ready', self._handle_dota_ready)
        self.dota.on(self.dota.EVENT_LOBBY_NEW, self._handle_lobby_created)
        self.dota.on(self.dota.EVENT_LOBBY_CHANGED, self._handle_lobby_changed)
        
        self.ready_event = threading.Event()
        self.lobby_created_event = threading.Event()
        self.lobby_data = None
        
    def _handle_logged_on(self):
        logger.info(f"[{self.username}] ‚úÖ –í—Ö–æ–¥ –≤ Steam –≤—ã–ø–æ–ª–Ω–µ–Ω")
        self.is_logged_in = True
        
    def _handle_disconnected(self):
        logger.warning(f"[{self.username}] ‚ö†Ô∏è –û—Ç–∫–ª—é—á–µ–Ω –æ—Ç Steam")
        self.is_logged_in = False
        
    def _handle_dota_ready(self):
        logger.info(f"[{self.username}] ‚úÖ Dota 2 –∫–ª–∏–µ–Ω—Ç –≥–æ—Ç–æ–≤")
        self.ready_event.set()
        
    def _handle_lobby_created(self, lobby):
        logger.info(f"[{self.username}] ‚úÖ –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ!")
        self.lobby_data = lobby
        self.current_lobby = lobby
        self.lobby_created_event.set()
        
    def _handle_lobby_changed(self, lobby):
        self.lobby_data = lobby
        self.current_lobby = lobby
        
    def login(self) -> bool:
        try:
            logger.info(f"[{self.username}] üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Steam...")
            result = self.steam.login(username=self.username, password=self.password)
            
            if result == EResult.OK:
                logger.info(f"[{self.username}] ‚úÖ –£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥ –≤ Steam")
                return True
            else:
                logger.error(f"[{self.username}] ‚ùå –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞: {result}")
                return False
        except Exception as e:
            logger.error(f"[{self.username}] ‚ùå –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—Ö–æ–¥–µ: {e}", exc_info=True)
            return False
    
    def launch_dota(self) -> bool:
        try:
            logger.info(f"[{self.username}] üéÆ –ó–∞–ø—É—Å–∫ Dota 2 (–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä—É)...")
            self.dota.launch()
            
            # –£–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è Pterodactyl (2 –º–∏–Ω—É—Ç—ã)
            if self.ready_event.wait(timeout=120):
                logger.info(f"[{self.username}] ‚úÖ Dota 2 –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω")
                return True
            else:
                logger.error(f"[{self.username}] ‚ùå –¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Dota 2 (120 —Å–µ–∫—É–Ω–¥)")
                return False
        except Exception as e:
            logger.error(f"[{self.username}] ‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Dota 2: {e}", exc_info=True)
            return False
    
    def create_lobby(self, lobby_name: str, password: str, server: str, mode: str) -> Optional[dict]:
        try:
            logger.info(f"[{self.username}] üéÆ –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏: {lobby_name}")
            
            server_region = self._get_server_region(server)
            game_mode = self._get_game_mode(mode)
            
            options = {
                'game_name': lobby_name,
                'pass_key': password,
                'server_region': server_region,
                'game_mode': game_mode,
                'allow_spectating': False,
                'allow_cheats': False,
                'dota_tv_delay': 2,
            }
            
            self.dota.create_practice_lobby(password=password, options=options)
            
            if self.lobby_created_event.wait(timeout=30):
                logger.info(f"[{self.username}] ‚úÖ –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ")
                
                lobby_info = {
                    'lobby_name': lobby_name,
                    'password': password,
                    'account': self.username,
                    'server': server,
                    'mode': mode
                }
                return lobby_info
            else:
                logger.error(f"[{self.username}] ‚ùå –¢–∞–π–º–∞—É—Ç —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏")
                return None
        except Exception as e:
            logger.error(f"[{self.username}] ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏: {e}", exc_info=True)
            return None
    
    def _get_server_region(self, server: str) -> EServerRegion:
        mapping = {
            'Stockholm': EServerRegion.Europe,
            'Europe West': EServerRegion.Europe,
            'Russia': EServerRegion.Europe,
            'US East': EServerRegion.USEast,
            'US West': EServerRegion.USWest,
        }
        return mapping.get(server, EServerRegion.Europe)
    
    def _get_game_mode(self, mode: str) -> DOTA_GameMode:
        mapping = {
            'Captains Mode': DOTA_GameMode.DOTA_GAMEMODE_CM,
            'All Pick': DOTA_GameMode.DOTA_GAMEMODE_AP,
            'Random Draft': DOTA_GameMode.DOTA_GAMEMODE_RD,
            'Single Draft': DOTA_GameMode.DOTA_GAMEMODE_SD,
        }
        return mapping.get(mode, DOTA_GameMode.DOTA_GAMEMODE_CM)
    
    def destroy_lobby(self):
        try:
            if self.current_lobby:
                logger.info(f"[{self.username}] üóëÔ∏è –ó–∞–∫—Ä—ã—Ç–∏–µ –ª–æ–±–±–∏")
                self.dota.destroy_lobby()
                self.current_lobby = None
        except Exception as e:
            logger.error(f"[{self.username}] ‚ùå –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ª–æ–±–±–∏: {e}")
    
    def disconnect(self):
        try:
            logger.info(f"[{self.username}] üëã –û—Ç–∫–ª—é—á–µ–Ω–∏–µ")
            if self.dota:
                self.dota.exit()
            if self.steam.logged_on:
                self.steam.logout()
        except Exception as e:
            logger.error(f"[{self.username}] ‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è: {e}")
    
    def run_client(self):
        self.steam.run_forever()


class SteamAccount:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ"""
    def __init__(self, username: str, password: str):
        self.username = username
        self.password = password
        self.bot_instance: Optional[DotaBot] = None
        self.current_lobby = None
        self.is_busy = False
        
    def to_dict(self):
        return {
            'username': self.username,
            'password': self.password
        }


class LobbyInfo:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–æ–±–±–∏"""
    def __init__(self, lobby_name: str, password: str, account: str):
        self.lobby_name = lobby_name  # "wb cup 1", "wb cup 2"
        self.password = password
        self.account = account
        self.created_at = datetime.now()
        self.players_count = 0
        self.status = "active"


class RealDota2BotV2:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π –±–æ—Ç"""
    
    def __init__(self):
        self.telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.admin_ids = [int(id.strip()) for id in os.getenv('ADMIN_IDS', '').split(',') if id.strip()]
        self.notification_chat_id = os.getenv('NOTIFICATION_CHAT_ID')
        self.notification_thread_id = int(os.getenv('NOTIFICATION_THREAD_ID', '0')) if os.getenv('NOTIFICATION_THREAD_ID') else None
        
        self.telegram_app = None
        
        # –•—Ä–∞–Ω–∏–ª–∏—â–µ
        self.steam_accounts: List[SteamAccount] = []
        self.active_lobbies: Dict[str, LobbyInfo] = {}  # "wb cup 1" -> LobbyInfo
        self.active_bots: Dict[str, DotaBot] = {}
        self.active_processes: Dict[str, Process] = {}  # username -> Process
        self.shutdown_events: Dict[str, multiprocessing.Event] = {}  # username -> Event
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        self.lobby_base_name = "wb cup"  # –ë–∞–∑–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
        self.server_region = "Stockholm"
        self.game_mode = "Captains Mode"
        
        # –°—á–µ—Ç—á–∏–∫ –ª–æ–±–±–∏ (–í–ê–ñ–ù–û: –ù–ï —Å–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ–∂–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–º–∏!)
        self.lobby_counter = 1
        
        # –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ
        self.schedule_config = {}
        self.scheduler = None
        
        # –ó–∞–≥—Ä—É–∑–∫–∞
        self.load_accounts()
        self.load_settings()
        self.load_schedule()
        
        # –í–ê–ñ–ù–û: –û—á–∏—â–∞–µ–º –≤—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ (–Ω–æ–≤–∞—è —Å–µ—Å—Å–∏—è = –Ω–æ–≤—ã–µ –ª–æ–±–±–∏)
        for account in self.steam_accounts:
            account.is_busy = False
            account.current_lobby = None
            account.bot_instance = None
        
        logger.info("üîÑ –í—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω—ã –¥–ª—è –Ω–æ–≤–æ–π —Å–µ—Å—Å–∏–∏")
        
        # –í–ê–ñ–ù–û: –£–±–∏–≤–∞–µ–º –≤—Å–µ —Å—Ç–∞—Ä—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã Python/Steam
        self.kill_old_processes()
        
    def kill_old_processes(self):
        """–£–±–∏–≤–∞–µ–º –í–°–ï —Å—Ç–∞—Ä—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã Steam/Dota –ê–ì–†–ï–°–°–ò–í–ù–û"""
        try:
            import subprocess
            import time
            
            logger.info("üî™ –û—á–∏—Å—Ç–∫–∞ –í–°–ï–• —Å—Ç–∞—Ä—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ Steam/Dota...")
            
            # –£–±–∏–≤–∞–µ–º –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã Steam –∏ Dota —Å —Ñ–ª–∞–≥–æ–º -9 (–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ)
            commands = [
                ['pkill', '-9', '-f', 'steam'],
                ['pkill', '-9', '-f', 'dota'],
                ['pkill', '-9', '-f', 'SteamClient'],
                ['pkill', '-9', '-f', 'steam_worker'],
            ]
            
            for cmd in commands:
                try:
                    subprocess.run(cmd, stderr=subprocess.DEVNULL, timeout=2)
                except:
                    pass
            
            # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
            time.sleep(2)
            
            logger.info("‚úÖ –í—Å–µ —Å—Ç–∞—Ä—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã —É–±–∏—Ç—ã!")
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–æ–≤: {e}")
        
    def load_accounts(self):
        try:
            if os.path.exists('steam_accounts.json'):
                with open('steam_accounts.json', 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for acc_data in data:
                        account = SteamAccount(acc_data['username'], acc_data['password'])
                        self.steam_accounts.append(account)
                logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.steam_accounts)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {e}")
            
    def save_accounts(self):
        try:
            data = [{'username': acc.username, 'password': acc.password} for acc in self.steam_accounts]
            with open('steam_accounts.json', 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
    
    def load_settings(self):
        try:
            if os.path.exists('lobby_settings.json'):
                with open('lobby_settings.json', 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                    self.lobby_base_name = settings.get('lobby_base_name', self.lobby_base_name)
                    self.server_region = settings.get('server_region', self.server_region)
                    self.game_mode = settings.get('game_mode', self.game_mode)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")
    
    def save_settings(self):
        try:
            settings = {
                'lobby_base_name': self.lobby_base_name,
                'server_region': self.server_region,
                'game_mode': self.game_mode
            }
            with open('lobby_settings.json', 'w', encoding='utf-8') as f:
                json.dump(settings, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")
    
    def load_schedule(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è"""
        try:
            if os.path.exists('schedule_config.json'):
                with open('schedule_config.json', 'r', encoding='utf-8') as f:
                    self.schedule_config = json.load(f)
                logger.info(f"üìÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–π: {len(self.schedule_config.get('schedules', []))}")
            else:
                # –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
                self.schedule_config = {
                    "enabled": False,
                    "timezone": "Europe/Moscow",
                    "schedules": []
                }
                self.save_schedule()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
            self.schedule_config = {"enabled": False, "timezone": "Europe/Moscow", "schedules": []}
    
    def save_schedule(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è"""
        try:
            with open('schedule_config.json', 'w', encoding='utf-8') as f:
                json.dump(self.schedule_config, f, ensure_ascii=False, indent=2)
            logger.info("üíæ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –µ—Å–ª–∏ –±–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω
            if hasattr(self, 'telegram_app') and self.telegram_app is not None:
                self.setup_scheduler()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
    
    def generate_password(self, length=8) -> str:
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    def generate_start_code(self, length=6) -> str:
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))
    
    def get_available_accounts(self) -> List[SteamAccount]:
        return [acc for acc in self.steam_accounts if not acc.is_busy]
    
    def is_admin(self, user_id: int) -> bool:
        return user_id in self.admin_ids
    
    def get_next_lobby_name(self) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—è –ª–æ–±–±–∏: wb cup 1, wb cup 2..."""
        name = f"{self.lobby_base_name} {self.lobby_counter}"
        self.lobby_counter += 1
        return name
    
    def get_main_keyboard(self):
        keyboard = [
            [InlineKeyboardButton("üéÆ –°–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏", callback_data="create_lobby")],
            [InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫ –ª–æ–±–±–∏", callback_data="list_lobbies")],
            [InlineKeyboardButton("ü§ñ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏", callback_data="manage_bots")],
            [InlineKeyboardButton("üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ", callback_data="schedule")],
            [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="settings"),
             InlineKeyboardButton("üìä –°—Ç–∞—Ç—É—Å", callback_data="status")],
        ]
        return InlineKeyboardMarkup(keyboard)
    
    def get_welcome_text(self):
        return f"""
üéÆ <b>Dota 2 Real Lobby Bot v2</b>

<b>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>
ü§ñ –ë–æ—Ç–æ–≤: {len(self.steam_accounts)}
üíö –°–≤–æ–±–æ–¥–Ω—ã—Ö: {len(self.get_available_accounts())}
üéØ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ–±–±–∏: {len(self.active_lobbies)}

<b>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏:</b>
üìù –ë–∞–∑–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ: {self.lobby_base_name}
üåç –°–µ—Ä–≤–µ—Ä: {self.server_region}
üéÆ –†–µ–∂–∏–º: {self.game_mode}

<b>üîó –†–µ–∂–∏–º: –†–ï–ê–õ–¨–ù–û–ï —Å–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏</b>
        """
    
    # ==================== –ö–û–ú–ê–ù–î–´ ====================
    
    async def cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id if hasattr(update, 'effective_user') else update.from_user.id
        
        if not self.is_admin(user_id):
            if hasattr(update, 'message') and update.message:
                await update.message.reply_text("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
            return
        
        text = self.get_welcome_text()
        keyboard = self.get_main_keyboard()
        
        if hasattr(update, 'message') and update.message:
            await update.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)
        elif hasattr(update, 'callback_query') and update.callback_query:
            try:
                await update.callback_query.edit_message_text(text, parse_mode='HTML', reply_markup=keyboard)
            except:
                await update.callback_query.message.reply_text(text, parse_mode='HTML', reply_markup=keyboard)
    
    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        
        if not self.is_admin(query.from_user.id):
            await query.edit_message_text("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞")
            return
            
        data = query.data
        
        try:
            if data == "create_lobby":
                return await self.handle_create_lobby_request(update, context)
            elif data == "list_lobbies":
                await self.handle_list_lobbies(query)
            elif data == "manage_bots":
                await self.handle_manage_bots(query)
            elif data == "add_bot":
                return await self.handle_add_bot_request(update, context)
            elif data.startswith("delete_bot_"):
                username = data.replace("delete_bot_", "")
                await self.handle_delete_bot_confirm(query, username)
            elif data.startswith("confirm_delete_"):
                username = data.replace("confirm_delete_", "")
                await self.handle_delete_bot(query, username)
            elif data.startswith("edit_bot_"):
                return await self.handle_edit_bot_request(update, context)
            elif data == "select_bots":
                return await self.handle_select_bots_menu(update, context)
            elif data == "schedule":
                await self.handle_schedule(query)
            elif data == "match_view_active":
                await self.handle_view_active_matches(query)
            elif data.startswith("schedule_"):
                await self.handle_schedule_action(query, data)
            elif data.startswith("match_"):
                return await self.handle_match_action(update, context)
            elif data == "settings":
                await self.handle_settings(query)
            elif data == "status":
                await self.handle_status(query)
            elif data == "back_main":
                await self.handle_back_to_main(query)
            elif data.startswith("close_lobby_"):
                lobby_name = data.replace("close_lobby_", "")
                await self.handle_close_lobby(query, lobby_name)
            elif data == "destroy_all_lobbies":
                await self.handle_destroy_all_lobbies(query)
            elif data.startswith("cancel_creation_"):
                username = data.replace("cancel_creation_", "")
                await self.handle_cancel_creation(query, username)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {data}: {e}", exc_info=True)
            try:
                await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞: {e}", reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
                ]]))
            except:
                pass
    
    # ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ë–û–¢–ê–ú–ò ====================
    
    async def handle_manage_bots(self, query):
        """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞–º–∏"""
        if not self.steam_accounts:
            await query.edit_message_text(
                "ü§ñ <b>–ù–µ—Ç –±–æ—Ç–æ–≤</b>\n\n–î–æ–±–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_bot"),
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
                ]])
            )
            return
        
        message = "<b>ü§ñ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏</b>\n\n"
        keyboard = []
        
        for idx, acc in enumerate(self.steam_accounts, 1):
            status = "üî¥ –ó–∞–Ω—è—Ç" if acc.is_busy else "üü¢ –°–≤–æ–±–æ–¥–µ–Ω"
            message += f"{idx}. <code>{acc.username}</code> - {status}\n"
            if acc.current_lobby:
                message += f"   ‚îî –õ–æ–±–±–∏: {acc.current_lobby}\n"
            
            keyboard.append([
                InlineKeyboardButton(f"‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å {idx}", callback_data=f"edit_bot_{acc.username}"),
                InlineKeyboardButton(f"üóëÔ∏è –£–¥–∞–ª–∏—Ç—å {idx}", callback_data=f"delete_bot_{acc.username}")
            ])
        
        message += f"\n<b>–í—Å–µ–≥–æ:</b> {len(self.steam_accounts)}\n"
        message += f"<b>–°–≤–æ–±–æ–¥–Ω—ã—Ö:</b> {len(self.get_available_accounts())}"
        
        keyboard.append([
            InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –±–æ—Ç–∞", callback_data="add_bot")
        ])
        
        # –ö–Ω–æ–ø–∫–∞ "–†–∞—Å–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ –ª–æ–±–±–∏" (–µ—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ)
        if self.active_lobbies:
            keyboard.append([
                InlineKeyboardButton("üî• –†–∞—Å–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ –ª–æ–±–±–∏", callback_data="destroy_all_lobbies")
            ])
        
        keyboard.append([
            InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
        ])
        
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def handle_delete_bot_confirm(self, query, username: str):
        """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è"""
        account = next((acc for acc in self.steam_accounts if acc.username == username), None)
        
        if not account:
            await query.answer("‚ùå –ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return
        
        if account.is_busy:
            await query.edit_message_text(
                f"‚ùå <b>–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∑–∞–Ω—è—Ç—ã–π –±–æ—Ç!</b>\n\n"
                f"–ë–æ—Ç <code>{username}</code> —Å–µ–π—á–∞—Å —Å–æ–∑–¥–∞–µ—Ç –ª–æ–±–±–∏.\n"
                f"–°–Ω–∞—á–∞–ª–∞ –∑–∞–∫—Ä–æ–π—Ç–µ –ª–æ–±–±–∏.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="manage_bots")
                ]])
            )
            return
        
        await query.edit_message_text(
            f"üóëÔ∏è <b>–£–¥–∞–ª–∏—Ç—å –±–æ—Ç–∞?</b>\n\n"
            f"–ë–æ—Ç: <code>{username}</code>\n\n"
            f"‚ö†Ô∏è –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å!",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_delete_{username}"),
                InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="manage_bots")
            ]])
        )
    
    async def handle_delete_bot(self, query, username: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ –±–æ—Ç–∞"""
        account = next((acc for acc in self.steam_accounts if acc.username == username), None)
        
        if account:
            self.steam_accounts.remove(account)
            self.save_accounts()
            
            await query.answer(f"‚úÖ –ë–æ—Ç {username} —É–¥–∞–ª–µ–Ω!", show_alert=True)
            await self.handle_manage_bots(query)
        else:
            await query.answer("‚ùå –ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
    
    async def handle_edit_bot_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ó–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞"""
        query = update.callback_query
        username = query.data.replace("edit_bot_", "")
        account = next((acc for acc in self.steam_accounts if acc.username == username), None)
        
        if not account:
            await query.answer("‚ùå –ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return ConversationHandler.END
        
        if account.is_busy:
            await query.edit_message_text(
                f"‚ùå <b>–ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å –∑–∞–Ω—è—Ç—ã–π –±–æ—Ç!</b>\n\n"
                f"–ë–æ—Ç <code>{username}</code> —Å–µ–π—á–∞—Å —Å–æ–∑–¥–∞–µ—Ç –ª–æ–±–±–∏.",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="manage_bots")
                ]])
            )
            return ConversationHandler.END
        
        context.user_data['editing_bot'] = username
        
        await query.edit_message_text(
            f"<b>‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞</b>\n\n"
            f"–¢–µ–∫—É—â–∏–π –ª–æ–≥–∏–Ω: <code>{username}</code>\n\n"
            f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            f"<code>–Ω–æ–≤—ã–π_–ª–æ–≥–∏–Ω –Ω–æ–≤—ã–π_–ø–∞—Ä–æ–ª—å</code>\n\n"
            f"–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã",
            parse_mode='HTML'
        )
        
        return WAITING_EDIT_BOT_DATA
    
    async def handle_edit_bot_data_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –±–æ—Ç–∞"""
        try:
            old_username = context.user_data.get('editing_bot')
            parts = update.message.text.strip().split()
            
            if len(parts) != 2:
                await update.message.reply_text(
                    "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç!\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: <code>–ª–æ–≥–∏–Ω –ø–∞—Ä–æ–ª—å</code>",
                    parse_mode='HTML'
                )
                return WAITING_EDIT_BOT_DATA
            
            new_username, new_password = parts
            
            account = next((acc for acc in self.steam_accounts if acc.username == old_username), None)
            
            if not account:
                await update.message.reply_text("‚ùå –ë–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", reply_markup=self.get_main_keyboard())
                return ConversationHandler.END
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—É–±–ª–∏–∫–∞—Ç–∞
            if new_username != old_username and any(acc.username == new_username for acc in self.steam_accounts):
                await update.message.reply_text(
                    f"‚ùå –ë–æ—Ç <code>{new_username}</code> —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!",
                    parse_mode='HTML'
                )
                return WAITING_EDIT_BOT_DATA
            
            # –û–±–Ω–æ–≤–ª—è–µ–º
            account.username = new_username
            account.password = new_password
            self.save_accounts()
            
            await update.message.reply_text(
                f"‚úÖ <b>–ë–æ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!</b>\n\n"
                f"–°—Ç–∞—Ä—ã–π –ª–æ–≥–∏–Ω: <code>{old_username}</code>\n"
                f"–ù–æ–≤—ã–π –ª–æ–≥–∏–Ω: <code>{new_username}</code>",
                parse_mode='HTML',
                reply_markup=self.get_main_keyboard()
            )
            
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞")
            return WAITING_EDIT_BOT_DATA
    
    async def handle_add_bot_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.edit_message_text(
            "<b>‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞</b>\n\n"
            "–§–æ—Ä–º–∞—Ç: <code>–ª–æ–≥–∏–Ω –ø–∞—Ä–æ–ª—å</code>\n\n"
            "–ü—Ä–∏–º–µ—Ä: <code>mylogin123 mypass456</code>",
            parse_mode='HTML'
        )
        return WAITING_ACCOUNT_DATA
    
    async def handle_account_data_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        try:
            parts = update.message.text.strip().split()
            
            if len(parts) != 2:
                await update.message.reply_text("‚ùå –§–æ—Ä–º–∞—Ç: <code>–ª–æ–≥–∏–Ω –ø–∞—Ä–æ–ª—å</code>", parse_mode='HTML')
                return WAITING_ACCOUNT_DATA
            
            username, password = parts
            
            if any(acc.username == username for acc in self.steam_accounts):
                await update.message.reply_text(f"‚ùå –ë–æ—Ç <code>{username}</code> —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω!", parse_mode='HTML')
                return WAITING_ACCOUNT_DATA
            
            account = SteamAccount(username, password)
            self.steam_accounts.append(account)
            self.save_accounts()
            
            await update.message.reply_text(
                f"‚úÖ <b>–ë–æ—Ç –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
                f"–õ–æ–≥–∏–Ω: <code>{username}</code>\n"
                f"–í—Å–µ–≥–æ: {len(self.steam_accounts)}",
                parse_mode='HTML',
                reply_markup=self.get_main_keyboard()
            )
            
            return ConversationHandler.END
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è: {e}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞")
            return WAITING_ACCOUNT_DATA
    
    # ==================== –°–û–ó–î–ê–ù–ò–ï –õ–û–ë–ë–ò –° –í–´–ë–û–†–û–ú –ë–û–¢–û–í ====================
    
    async def handle_create_lobby_request(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        available = len(self.get_available_accounts())
        
        if available == 0:
            await query.edit_message_text(
                "‚ùå <b>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –±–æ—Ç–æ–≤!</b>\n\n–î–æ–±–∞–≤—å—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_bot"),
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
                ]])
            )
            return ConversationHandler.END
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –±–æ—Ç–æ–≤
        context.user_data['selected_bots'] = []
        
        await query.edit_message_text(
            f"<b>üéÆ –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏</b>\n\n"
            f"–î–æ—Å—Ç—É–ø–Ω–æ –±–æ—Ç–æ–≤: <b>{available}</b>\n\n"
            f"‚ö†Ô∏è –ë–æ—Ç –∑–∞–π–¥–µ—Ç –≤ Steam –∏ —Å–æ–∑–¥–∞—Å—Ç –ª–æ–±–±–∏ –≤ Dota 2!\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ –±–æ—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏:",
            parse_mode='HTML'
        )
        
        return await self.handle_select_bots_menu(update, context)
    
    async def handle_select_bots_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ –±–æ—Ç–æ–≤"""
        query = update.callback_query if hasattr(update, 'callback_query') else None
        
        selected = context.user_data.get('selected_bots', [])
        available = self.get_available_accounts()
        
        message = "<b>üéÆ –í—ã–±–æ—Ä –±–æ—Ç–æ–≤ –¥–ª—è –ª–æ–±–±–∏</b>\n\n"
        message += f"–í—ã–±—Ä–∞–Ω–æ: <b>{len(selected)}</b>\n\n"
        
        keyboard = []
        for acc in available:
            is_selected = acc.username in selected
            emoji = "‚úÖ" if is_selected else "‚¨ú"
            keyboard.append([
                InlineKeyboardButton(
                    f"{emoji} {acc.username}",
                    callback_data=f"toggle_bot_{acc.username}"
                )
            ])
        
        if selected:
            keyboard.append([
                InlineKeyboardButton(f"üéÆ –°–æ–∑–¥–∞—Ç—å {len(selected)} –ª–æ–±–±–∏", callback_data="confirm_bot_selection")
            ])
        
        keyboard.append([
            InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="back_main")
        ])
        
        if query:
            try:
                await query.edit_message_text(
                    message,
                    parse_mode='HTML',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except:
                await query.message.reply_text(
                    message,
                    parse_mode='HTML',
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
        
        return WAITING_SELECT_BOTS
    
    async def handle_toggle_bot_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –±–æ—Ç–∞"""
        query = update.callback_query
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º username –∏–∑ callback_data
        username = query.data.replace("toggle_bot_", "")
        
        selected = context.user_data.get('selected_bots', [])
        
        if username in selected:
            selected.remove(username)
            await query.answer(f"‚ùå {username} —É–±—Ä–∞–Ω", show_alert=False)
        else:
            selected.append(username)
            await query.answer(f"‚úÖ {username} –≤—ã–±—Ä–∞–Ω", show_alert=False)
        
        context.user_data['selected_bots'] = selected
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é
        await self.handle_select_bots_menu(update, context)
    
    async def handle_confirm_bot_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –±–æ—Ç–æ–≤ –∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã"""
        query = update.callback_query
        selected = context.user_data.get('selected_bots', [])
        
        if not selected:
            await query.answer("‚ùå –í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã 1 –±–æ—Ç–∞", show_alert=True)
            return WAITING_SELECT_BOTS
        
        count = len(selected)
        
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã
        keyboard = [
            [InlineKeyboardButton("‚öîÔ∏è Captains Mode", callback_data="mode_Captains Mode")],
            [InlineKeyboardButton("üé≤ All Pick", callback_data="mode_All Pick")],
            [InlineKeyboardButton("üìã Captains Draft", callback_data="mode_Captains Draft")],
            [InlineKeyboardButton("üéØ Mid Only", callback_data="mode_Mid Only")],
            [InlineKeyboardButton("ü•ä 1v1 Solo Mid", callback_data="mode_1v1 Solo Mid")],
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="select_bots")]
        ]
        
        await query.edit_message_text(
            f"<b>üéÆ –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã</b>\n\n"
            f"–í—ã–±—Ä–∞–Ω–æ –±–æ—Ç–æ–≤: <b>{count}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –∏–≥—Ä—ã:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        return WAITING_GAME_MODE
    
    async def handle_game_mode_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã –∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Å–µ—Ä–∏–∏"""
        query = update.callback_query
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–∂–∏–º –∏–∑ callback_data
        game_mode = query.data.replace("mode_", "")
        context.user_data['game_mode'] = game_mode
        
        count = len(context.user_data.get('selected_bots', []))
        
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Å–µ—Ä–∏–∏ –∏–≥—Ä
        keyboard = [
            [InlineKeyboardButton("1Ô∏è‚É£ –û–¥–Ω–∞ –∏–≥—Ä–∞ (BO1)", callback_data="series_bo1")],
            [InlineKeyboardButton("2Ô∏è‚É£ –î–≤–µ –∏–≥—Ä—ã (BO2)", callback_data="series_bo2")],
            [InlineKeyboardButton("3Ô∏è‚É£ –î–æ 2 –ø–æ–±–µ–¥ (BO3)", callback_data="series_bo3")],
            [InlineKeyboardButton("5Ô∏è‚É£ –î–æ 3 –ø–æ–±–µ–¥ (BO5)", callback_data="series_bo5")],
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="confirm_bot_selection")]
        ]
        
        await query.edit_message_text(
            f"<b>üéØ –í—ã–±–æ—Ä —Å–µ—Ä–∏–∏ –∏–≥—Ä</b>\n\n"
            f"–ë–æ—Ç–æ–≤: <b>{count}</b>\n"
            f"–†–µ–∂–∏–º: <b>{game_mode}</b>\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Å–µ—Ä–∏–∏:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        
        return WAITING_SERIES_TYPE
    
    async def handle_series_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Å–µ—Ä–∏–∏ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏"""
        query = update.callback_query
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–µ—Ä–∏—é –∏–∑ callback_data
        series_type = query.data.replace("series_", "")
        context.user_data['series_type'] = series_type
        
        selected = context.user_data.get('selected_bots', [])
        game_mode = context.user_data.get('game_mode')
        count = len(selected)
        
        status_msg = await query.edit_message_text(
            f"‚è≥ <b>–°–æ–∑–¥–∞—é {count} –ª–æ–±–±–∏...</b>\n\n"
            f"üéÆ –†–µ–∂–∏–º: {game_mode}\n"
            f"üéØ –°–µ—Ä–∏—è: {series_type.upper()}\n\n"
            f"üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Steam –∏ –∑–∞–ø—É—Å–∫ Dota 2...\n"
            f"<i>–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 1-2 –º–∏–Ω—É—Ç—ã</i>",
            parse_mode='HTML'
        )
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã
        selected_accounts = [acc for acc in self.steam_accounts if acc.username in selected]
        
        created_lobbies = await self.create_multiple_real_lobbies_from_accounts(
            selected_accounts,
            status_msg,
            context,
            game_mode=game_mode,
            series_type=series_type
        )
        
        if not created_lobbies:
            await status_msg.edit_text(
                "‚ùå <b>–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏</b>\n\n"
                "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π",
                parse_mode='HTML',
                reply_markup=self.get_main_keyboard()
            )
            return ConversationHandler.END
        
        # –†–µ–∑—É–ª—å—Ç–∞—Ç
        message = f"‚úÖ <b>–°–æ–∑–¥–∞–Ω–æ {len(created_lobbies)} –ª–æ–±–±–∏!</b>\n\n"
        message += f"üéÆ –†–µ–∂–∏–º: <b>{game_mode}</b>\n"
        message += f"üéØ –°–µ—Ä–∏—è: <b>{series_type.upper()}</b>\n\n"
        
        for idx, lobby in enumerate(created_lobbies, 1):
            message += f"<b>{idx}. {lobby.lobby_name}</b>\n"
            message += f"üîí –ü–∞—Ä–æ–ª—å: <code>{lobby.password}</code>\n"
            message += f"ü§ñ –ë–æ—Ç: {lobby.account}\n\n"
        
        message += "<b>üéÆ –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω—ã –≤ –∏–≥—Ä–µ!</b>\n"
        message += "<i>–ò–≥—Ä–æ–∫–∏ –∏—â—É—Ç –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é: wb cup 1, wb cup 2...</i>"
        
        await status_msg.edit_text(
            message,
            parse_mode='HTML',
            reply_markup=self.get_main_keyboard()
        )
        
        # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ —Ç–æ–ø–∏–∫ –≥—Ä—É–ø–ø—ã
        if self.notification_chat_id:
            try:
                send_kwargs = {
                    'chat_id': self.notification_chat_id,
                    'text': message,
                    'parse_mode': 'HTML'
                }
                # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω ID —Ç–æ–ø–∏–∫–∞ - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Ç–æ–ø–∏–∫
                if self.notification_thread_id:
                    send_kwargs['message_thread_id'] = self.notification_thread_id
                
                await context.bot.send_message(**send_kwargs)
                logger.info(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ {'—Ç–æ–ø–∏–∫ ' + str(self.notification_thread_id) if self.notification_thread_id else '—á–∞—Ç'}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {e}")
        
        return ConversationHandler.END
    
    async def create_multiple_real_lobbies_from_accounts(
        self,
        accounts: List[SteamAccount],
        status_msg,
        context,
        game_mode: str = None,
        series_type: str = None
    ) -> List[LobbyInfo]:
        """–°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤"""
        created = []
        total = len(accounts)
        
        for idx, account in enumerate(accounts, 1):
            try:
                await status_msg.edit_text(
                    f"‚è≥ <b>–°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ {idx}/{total}</b>\n\n"
                    f"ü§ñ –ê–∫–∫–∞—É–Ω—Ç: {account.username}\n"
                    f"üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Steam...",
                    parse_mode='HTML'
                )
                
                account.is_busy = True
                lobby_info = await self.create_single_real_lobby(
                    account, 
                    status_msg,
                    game_mode=game_mode,
                    series_type=series_type
                )
                
                if lobby_info:
                    created.append(lobby_info)
                    logger.info(f"‚úÖ –õ–æ–±–±–∏ {idx} —Å–æ–∑–¥–∞–Ω–æ: {lobby_info.lobby_name}")
                else:
                    logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏ {idx}")
                    account.is_busy = False
                    
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ {idx}: {e}", exc_info=True)
                account.is_busy = False
        
        return created
    
    async def create_single_real_lobby(self, account: SteamAccount, status_msg, 
                                       game_mode: str = None, series_type: str = None, 
                                       lobby_name: str = None) -> Optional[LobbyInfo]:
        """–†–ï–ê–õ–¨–ù–û–ï —Å–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ —á–µ—Ä–µ–∑ Steam –∏ Dota 2 –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ"""
        process = None
        result_queue = None
        shutdown_event = None
        
        try:
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
            if not lobby_name:
                lobby_name = self.get_next_lobby_name()
            if not game_mode:
                game_mode = self.game_mode
            if not series_type:
                series_type = "bo1"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ–¥–Ω–∞ –∏–≥—Ä–∞
            
            password = self.generate_password()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Å –∫–Ω–æ–ø–∫–æ–π –æ—Ç–º–µ–Ω—ã
            cancel_keyboard = InlineKeyboardMarkup([[
                InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ", callback_data=f"cancel_creation_{account.username}")
            ]])
            await status_msg.edit_text(
                f"‚è≥ <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ª–æ–±–±–∏</b>\n\n"
                f"ü§ñ –ê–∫–∫–∞—É–Ω—Ç: {account.username}\n"
                f"üè∑Ô∏è –ù–∞–∑–≤–∞–Ω–∏–µ: {lobby_name}\n"
                f"üîê –ü–∞—Ä–æ–ª—å: {password}\n\n"
                f"‚è±Ô∏è –ó–∞–ø—É—Å–∫ Steam...",
                parse_mode='HTML',
                reply_markup=cancel_keyboard
            )
            
            # –°–æ–∑–¥–∞–µ–º –æ—á–µ—Ä–µ–¥—å –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏ event –¥–ª—è shutdown
            result_queue = multiprocessing.Queue()
            shutdown_event = multiprocessing.Event()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º Steam –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ
            process = Process(
                target=steam_worker_process,
                args=(
                    account.username,
                    account.password,
                    lobby_name,
                    password,
                    self.server_region,
                    game_mode,  # –†–µ–∂–∏–º –∏–≥—Ä—ã
                    series_type,  # –°–µ—Ä–∏—è –∏–≥—Ä
                    result_queue,
                    shutdown_event,
                )
            )
            process.start()
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º shutdown_event –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∑–∞–∫—Ä—ã—Ç–∏—è –ª–æ–±–±–∏
            self.shutdown_events[account.username] = shutdown_event
            
            # –ñ–¥–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (—Å —Ç–∞–π–º–∞—É—Ç–æ–º)
            max_wait_time = 180  # 3 –º–∏–Ω—É—Ç—ã (—É–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –º–µ–¥–ª–µ–Ω–Ω—ã—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π)
            start_time = time.time()
            result = None
            
            while time.time() - start_time < max_wait_time:
            await asyncio.sleep(2)
            
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
                elapsed = int(time.time() - start_time)
                if elapsed % 10 == 0:
            await status_msg.edit_text(
                        f"‚è≥ <b>–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ª–æ–±–±–∏</b>\n\n"
                        f"ü§ñ –ê–∫–∫–∞—É–Ω—Ç: {account.username}\n"
                        f"üè∑Ô∏è –ù–∞–∑–≤–∞–Ω–∏–µ: {lobby_name}\n"
                        f"üîê –ü–∞—Ä–æ–ª—å: {password}\n\n"
                        f"‚è±Ô∏è –ü—Ä–æ—à–ª–æ {elapsed} —Å–µ–∫...",
                        parse_mode='HTML',
                        reply_markup=cancel_keyboard
                    )
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥—å
                if not result_queue.empty():
                    result = result_queue.get()
                    break
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            if result and result.get('success'):
                logger.info(f"‚úÖ –†–ï–ê–õ–¨–ù–û–ï –ª–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ: {lobby_name}")
                
                # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –ª–æ–±–±–∏
            lobby_info = LobbyInfo(
                lobby_name=lobby_name,
                password=password,
                account=account.username,
            )
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º
            self.active_lobbies[lobby_name] = lobby_info
            account.is_busy = True
            account.current_lobby = lobby_name
            
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ—Ü–µ—Å—Å
                self.active_processes[account.username] = process
                
            return lobby_info
            else:
                error_msg = result.get('error', 'Unknown error') if result else 'Timeout'
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏: {error_msg}")
                
                # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
                account.is_busy = False
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º shutdown signal –∏ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
                if process and process.is_alive():
                    if shutdown_event:
                        logger.info(f"–û—Ç–ø—Ä–∞–≤–ª—è–µ–º shutdown signal –¥–ª—è {account.username}...")
                        shutdown_event.set()
                        process.join(timeout=10)  # –î–∞—ë–º 10 —Å–µ–∫ –Ω–∞ graceful shutdown
                    
                    if process.is_alive():
                        logger.warning(f"–ü—Ä–æ—Ü–µ—Å—Å {account.username} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...")
                        process.terminate()
                        process.join(timeout=5)
                    
                    if process.is_alive():
                        process.kill()
                        process.join(timeout=2)
                
                # –û—á–∏—Å—Ç–∫–∞
                if account.username in self.active_processes:
                    del self.active_processes[account.username]
                if account.username in self.shutdown_events:
                    del self.shutdown_events[account.username]
                
                return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –†–ï–ê–õ–¨–ù–û–ì–û –ª–æ–±–±–∏: {e}", exc_info=True)
            
            # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
            account.is_busy = False
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
            if process and process.is_alive():
                try:
                    if shutdown_event:
                        shutdown_event.set()
                        process.join(timeout=10)
                    
                    if process.is_alive():
                        process.terminate()
                        process.join(timeout=5)
                    
                    if process.is_alive():
                        process.kill()
                        process.join(timeout=2)
                except:
                    pass
            
            # –û—á–∏—Å—Ç–∫–∞
            if account.username in self.active_processes:
                del self.active_processes[account.username]
            if account.username in self.shutdown_events:
                del self.shutdown_events[account.username]
            
            return None
            
        finally:
            # –í–ê–ñ–ù–û: –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º result_queue –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —É—Ç–µ—á–µ–∫ —Ä–µ—Å—É—Ä—Å–æ–≤
            if result_queue is not None:
                try:
                    result_queue.close()
                    result_queue.join_thread()
                except Exception as cleanup_error:
                    logger.debug(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ result_queue: {cleanup_error}")
    
    # ==================== –°–ü–ò–°–û–ö –õ–û–ë–ë–ò ====================
    
    async def handle_list_lobbies(self, query):
        if not self.active_lobbies:
            await query.edit_message_text(
                "üìã <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ–±–±–∏</b>",
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üéÆ –°–æ–∑–¥–∞—Ç—å", callback_data="create_lobby"),
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
                ]])
            )
            return
        
        message = "<b>üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –ª–æ–±–±–∏:</b>\n\n"
        keyboard = []
        
        for idx, (lobby_name, lobby) in enumerate(self.active_lobbies.items(), 1):
            message += f"‚úÖ <b>{idx}. {lobby_name}</b>\n"
            message += f"üîí –ü–∞—Ä–æ–ª—å: <code>{lobby.password}</code>\n"
            message += f"ü§ñ –ë–æ—Ç: {lobby.account}\n"
            message += f"üë• –ò–≥—Ä–æ–∫–æ–≤: {lobby.players_count}/10\n\n"
            
            keyboard.append([
                InlineKeyboardButton(f"‚ùå –ó–∞–∫—Ä—ã—Ç—å {idx}", callback_data=f"close_lobby_{lobby_name}")
            ])
        
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def handle_close_lobby(self, query, lobby_name: str):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ª–æ–±–±–∏ –∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞"""
        if lobby_name in self.active_lobbies:
            lobby = self.active_lobbies[lobby_name]
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å Steam (–µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω)
            if lobby.account in self.active_processes:
                process = self.active_processes[lobby.account]
                try:
                    if process.is_alive():
                        logger.info(f"–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –¥–ª—è {lobby.account}, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª shutdown...")
                        
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º shutdown_event –¥–ª—è graceful shutdown
                        if lobby.account in self.shutdown_events:
                            shutdown_event = self.shutdown_events[lobby.account]
                            shutdown_event.set()
                            logger.info(f"–ñ–¥—ë–º —É–¥–∞–ª–µ–Ω–∏—è –ª–æ–±–±–∏ (–º–∞–∫—Å 20 —Å–µ–∫—É–Ω–¥)...")
                            
                            # –î–∞—ë–º –ø—Ä–æ—Ü–µ—Å—Å—É 20 —Å–µ–∫—É–Ω–¥ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ –ª–æ–±–±–∏
                            process.join(timeout=20)
                        
                        # –ï—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è - –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
                        if process.is_alive():
                            logger.warning(f"–ü—Ä–æ—Ü–µ—Å—Å –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...")
                            process.terminate()
                            process.join(timeout=2)
                        
                        if process.is_alive():
                            logger.warning(f"–£–±–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å...")
                            process.kill()
                            process.join(timeout=2)
                        
                        logger.info(f"‚úÖ –ü—Ä–æ—Ü–µ—Å—Å {lobby.account} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                        
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞: {e}")
                finally:
                    if lobby.account in self.active_processes:
                        del self.active_processes[lobby.account]
                    if lobby.account in self.shutdown_events:
                        del self.shutdown_events[lobby.account]
            
            # –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–æ—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å —Å—Ç–∞—Ä—ã–π)
            if lobby.account in self.active_bots:
                try:
                bot = self.active_bots[lobby.account]
                bot.destroy_lobby()
                bot.disconnect()
                except:
                    pass
                del self.active_bots[lobby.account]
            
            # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
            for account in self.steam_accounts:
                if account.username == lobby.account:
                    account.is_busy = False
                    account.current_lobby = None
                    account.bot_instance = None
                    break
            
            # –£–¥–∞–ª—è–µ–º –ª–æ–±–±–∏
            del self.active_lobbies[lobby_name]
            logger.info(f"‚úÖ –õ–æ–±–±–∏ {lobby_name} –∑–∞–∫—Ä—ã—Ç–æ")
            
            await query.answer("‚úÖ –õ–æ–±–±–∏ –∑–∞–∫—Ä—ã—Ç–æ!", show_alert=True)
            await self.handle_list_lobbies(query)
        else:
            await query.answer("‚ùå –õ–æ–±–±–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", show_alert=True)
    
    async def handle_destroy_all_lobbies(self, query):
        """–£–¥–∞–ª–µ–Ω–∏–µ –í–°–ï–• –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ–±–±–∏"""
        if not self.active_lobbies:
            await query.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ–±–±–∏", show_alert=True)
            return
        
        lobby_count = len(self.active_lobbies)
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        await query.edit_message_text(
            f"üî• <b>–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ª–æ–±–±–∏...</b>\n\n"
            f"–ù–∞–π–¥–µ–Ω–æ –ª–æ–±–±–∏: {lobby_count}\n"
            f"‚è≥ –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å—ã...",
            parse_mode='HTML'
        )
        
        import subprocess
        closed_count = 0
        
        # –ö–æ–ø–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –ª–æ–±–±–∏ (—á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏)
        lobbies_to_close = list(self.active_lobbies.items())
        
        for lobby_name, lobby in lobbies_to_close:
            try:
                # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å Steam (–µ—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω)
                if lobby.account in self.active_processes:
                    process = self.active_processes[lobby.account]
                    try:
                        if process.is_alive():
                            logger.info(f"–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –¥–ª—è {lobby.account}, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª shutdown...")
                            
                            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º shutdown_event –¥–ª—è graceful shutdown
                            if lobby.account in self.shutdown_events:
                                shutdown_event = self.shutdown_events[lobby.account]
                                shutdown_event.set()
                                logger.info(f"–ñ–¥—ë–º —É–¥–∞–ª–µ–Ω–∏—è –ª–æ–±–±–∏ {lobby_name} (–º–∞–∫—Å 20 —Å–µ–∫—É–Ω–¥)...")
                                
                                # –î–∞—ë–º –ø—Ä–æ—Ü–µ—Å—Å—É 20 —Å–µ–∫—É–Ω–¥ –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ –ª–æ–±–±–∏
                                process.join(timeout=20)
                            
                            # –ï—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è - –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
                            if process.is_alive():
                                logger.warning(f"–ü—Ä–æ—Ü–µ—Å—Å {lobby.account} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...")
                                process.terminate()
                                process.join(timeout=2)
                            
                            if process.is_alive():
                                logger.warning(f"–£–±–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å {lobby.account}...")
                                process.kill()
                                process.join(timeout=2)
                            
                            logger.info(f"‚úÖ –ü—Ä–æ—Ü–µ—Å—Å {lobby.account} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                            
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ {lobby.account}: {e}")
                    finally:
                        if lobby.account in self.active_processes:
                            del self.active_processes[lobby.account]
                        if lobby.account in self.shutdown_events:
                            del self.shutdown_events[lobby.account]
                
                # –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–æ—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
                if lobby.account in self.active_bots:
                    try:
                        bot = self.active_bots[lobby.account]
                        bot.destroy_lobby()
                        bot.disconnect()
                    except:
                        pass
                    del self.active_bots[lobby.account]
                
                # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
                for account in self.steam_accounts:
                    if account.username == lobby.account:
                        account.is_busy = False
                        account.current_lobby = None
                        account.bot_instance = None
                        break
                
                # –£–¥–∞–ª—è–µ–º –ª–æ–±–±–∏
                if lobby_name in self.active_lobbies:
                    del self.active_lobbies[lobby_name]
                
                closed_count += 1
                logger.info(f"‚úÖ –õ–æ–±–±–∏ {lobby_name} —É–¥–∞–ª–µ–Ω–æ ({closed_count}/{lobby_count})")
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ª–æ–±–±–∏ {lobby_name}: {e}")
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ steam/dota
        logger.info("üî™ –§–∏–Ω–∞–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...")
        try:
            subprocess.run(['pkill', '-9', '-f', 'steam'], stderr=subprocess.DEVNULL)
            subprocess.run(['pkill', '-9', '-f', 'dota'], stderr=subprocess.DEVNULL)
        except:
            pass
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        await query.edit_message_text(
            f"‚úÖ <b>–í—Å–µ –ª–æ–±–±–∏ —É–¥–∞–ª–µ–Ω—ã!</b>\n\n"
            f"üî• –ó–∞–∫—Ä—ã—Ç–æ: {closed_count}\n"
            f"üíö –í—Å–µ –±–æ—Ç—ã –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω—ã\n"
            f"üßπ –ü—Ä–æ—Ü–µ—Å—Å—ã –æ—á–∏—â–µ–Ω—ã",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="manage_bots")
            ]])
        )
    
    async def handle_cancel_creation(self, query, username: str):
        """–û—Ç–º–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏"""
        await query.answer("üõë –û—Ç–º–µ–Ω—è–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ...", show_alert=True)
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º shutdown signal –ø—Ä–æ—Ü–µ—Å—Å—É
        if username in self.shutdown_events:
            logger.info(f"–û—Ç–º–µ–Ω–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ –¥–ª—è {username}")
            self.shutdown_events[username].set()
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
            if username in self.active_processes:
                process = self.active_processes[username]
                try:
                    if process.is_alive():
                        process.join(timeout=10)
                        if process.is_alive():
                            process.terminate()
                            process.join(timeout=2)
                        if process.is_alive():
                            process.kill()
                            process.join(timeout=2)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ: {e}")
                finally:
                    if username in self.active_processes:
                        del self.active_processes[username]
                    if username in self.shutdown_events:
                        del self.shutdown_events[username]
            
            # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç
            for account in self.steam_accounts:
                if account.username == username:
                    account.is_busy = False
                    account.current_lobby = None
                    account.bot_instance = None
                    break
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        await query.edit_message_text(
            "‚ùå <b>–°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ</b>",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
            ]])
        )
    
    # ==================== –û–°–¢–ê–õ–¨–ù–û–ï ====================
    
    async def handle_settings(self, query):
        message = f"""
<b>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>

üìù –ë–∞–∑–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ: {self.lobby_base_name}
   (–õ–æ–±–±–∏ –±—É–¥—É—Ç: {self.lobby_base_name} 1, {self.lobby_base_name} 2...)

üåç –°–µ—Ä–≤–µ—Ä: {self.server_region}
üéÆ –†–µ–∂–∏–º: {self.game_mode}
üë• –ó—Ä–∏—Ç–µ–ª–∏: –ù–µ—Ç
üéØ –ß–∏—Ç—ã: –ù–µ—Ç
        """
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
            ]])
        )
    
    async def handle_schedule(self, query):
        """–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º –º–∞—Ç—á–µ–π"""
        all_matches = self.schedule_config.get('matches', [])
        is_enabled = self.schedule_config.get('enabled', False)
        
        # –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏ –∞–∫—Ç–∏–≤–Ω—ã–µ
        scheduled_matches = [m for m in all_matches if m.get('status') == 'scheduled']
        active_matches = [m for m in all_matches if m.get('status') == 'active']
        
        message = f"""
<b>üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –º–∞—Ç—á–µ–π</b>

<b>–°—Ç–∞—Ç—É—Å:</b> {'üü¢ –í–∫–ª—é—á–µ–Ω–æ' if is_enabled else 'üî¥ –í—ã–∫–ª—é—á–µ–Ω–æ'}
<b>–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å:</b> {self.schedule_config.get('timezone', 'Europe/Moscow')}

<b>üìã –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ:</b> {len(scheduled_matches)}
<b>üéÆ –ê–∫—Ç–∏–≤–Ω—ã—Ö:</b> {len(active_matches)}
"""
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–∞—Ç—á–∏
        if scheduled_matches:
            message += "\n<b>üìã –ü—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –º–∞—Ç—á–∏:</b>\n"
            for idx, match in enumerate(scheduled_matches, 1):
                status_emoji = "‚úÖ" if match.get('enabled', False) else "‚è∏Ô∏è"
                team1 = match.get('team1', '???')
                team2 = match.get('team2', '???')
                date = match.get('date', '???.??.????')
                time_str = match.get('time', '??:??')
                series = match.get('series_type', 'bo1').upper()
                mode = match.get('game_mode', 'CM')
                
                message += f"{status_emoji} <b>{idx}.</b> {team1} vs {team2}\n"
                message += f"     üìÖ {date} ‚è∞ {time_str} üéØ {series} üéÆ {mode}\n"
        
        keyboard = []
        
        # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        keyboard.append([
            InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–∞—Ç—á", callback_data="match_add")
        ])
        
        if active_matches:
            keyboard.append([
                InlineKeyboardButton(f"üéÆ –ê–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏ ({len(active_matches)})", callback_data="match_view_active")
            ])
        
        if all_matches:
            keyboard.append([
                InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="match_edit_menu"),
                InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –≤—Å—ë", callback_data="match_delete_all")
            ])
        
        keyboard.append([
            InlineKeyboardButton(f"{'üî¥ –í—ã–∫–ª—é—á–∏—Ç—å' if is_enabled else 'üü¢ –í–∫–ª—é—á–∏—Ç—å'}", 
                               callback_data="schedule_toggle_global"),
            InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
        ])
        
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def handle_view_active_matches(self, query):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π"""
        all_matches = self.schedule_config.get('matches', [])
        active_matches = [m for m in all_matches if m.get('status') == 'active']
        
        if not active_matches:
            await query.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π", show_alert=True)
            return
        
        message = "<b>üéÆ –ê–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Ç—á–∏:</b>\n\n"
        
        for idx, match in enumerate(active_matches, 1):
            team1 = match.get('team1', '???')
            team2 = match.get('team2', '???')
            series = match.get('series_type', 'bo1').upper()
            mode = match.get('game_mode', 'CM')
            lobby_name = f"{team1} vs {team2}"
            
            message += f"<b>{idx}. {lobby_name}</b>\n"
            message += f"üéØ {series} | üéÆ {mode}\n"
            
            # –ò—â–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ–±–±–∏, –µ—Å–ª–∏ –æ–Ω–æ —Å–æ–∑–¥–∞–Ω–æ
            if lobby_name in self.active_lobbies:
                lobby = self.active_lobbies[lobby_name]
                message += f"üîí –ü–∞—Ä–æ–ª—å: <code>{lobby.password}</code>\n"
                message += f"üë• –ò–≥—Ä–æ–∫–æ–≤: {lobby.players_count}/10\n"
            
            message += "\n"
        
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="schedule")
            ]])
        )
    
    async def handle_schedule_action(self, query, data: str):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º (—Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å)"""
        if data == "schedule_toggle_global":
            # –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –≤—Å—ë —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
            self.schedule_config['enabled'] = not self.schedule_config.get('enabled', False)
            self.save_schedule()
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
            self.setup_scheduler()
            
            await query.answer(
                f"‚úÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ {'–≤–∫–ª—é—á–µ–Ω–æ' if self.schedule_config['enabled'] else '–≤—ã–∫–ª—é—á–µ–Ω–æ'}!",
                show_alert=True
            )
            await self.handle_schedule(query)
    
    async def handle_match_action(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π —Å –º–∞—Ç—á–∞–º–∏"""
        query = update.callback_query
        data = query.data
        
        if data == "match_add":
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –º–∞—Ç—á–µ–π
            matches = self.schedule_config.get('matches', [])
            total_accounts = len(self.steam_accounts)
            
            if len(matches) >= total_accounts:
                await query.answer(
                    f"‚ùå –ù–µ–ª—å–∑—è –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ {total_accounts} –º–∞—Ç—á–µ–π!\n"
                    f"–£ –≤–∞—Å —Ç–æ–ª—å–∫–æ {total_accounts} –∞–∫–∫–∞—É–Ω—Ç–æ–≤ Steam.\n"
                    f"–î–æ–±–∞–≤—å—Ç–µ –µ—â—ë –∞–∫–∫–∞—É–Ω—Ç—ã —á–µ—Ä–µ–∑ '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞–º–∏'",
                    show_alert=True
                )
                return
            # –ù–∞—á–∞–ª–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–∞—Ç—á–∞
            await query.edit_message_text(
                "<b>‚ûï –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–∞—Ç—á–∞</b>\n\n"
                "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–π –∫–æ–º–∞–Ω–¥—ã:\n\n"
                "<b>–ü—Ä–∏–º–µ—Ä:</b> <code>team zxc</code>",
                parse_mode='HTML'
            )
            return WAITING_MATCH_TEAM1
        
        elif data == "match_delete_all":
            # –£–¥–∞–ª–∏—Ç—å –≤—Å–µ –º–∞—Ç—á–∏
            self.schedule_config['matches'] = []
            self.save_schedule()
            await query.answer("‚úÖ –í—Å–µ –º–∞—Ç—á–∏ —É–¥–∞–ª–µ–Ω—ã!", show_alert=True)
            await self.handle_schedule(query)
        
        elif data == "match_edit_menu":
            # –ú–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –º–∞—Ç—á–µ–π
            matches = self.schedule_config.get('matches', [])
            
            message = "<b>‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—á–µ–π</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Ç—á:\n\n"
            keyboard = []
            
            for idx, match in enumerate(matches, 1):
                team1 = match.get('team1', '???')
                team2 = match.get('team2', '???')
                keyboard.append([
                    InlineKeyboardButton(
                        f"{idx}. {team1} vs {team2}",
                        callback_data=f"match_edit_{match['id']}"
                    )
                ])
            
            keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="schedule")])
            
            await query.edit_message_text(
                message,
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        
        elif data.startswith("match_edit_"):
            # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Ç—á–∞
            match_id = int(data.replace("match_edit_", ""))
            context.user_data['editing_match_id'] = match_id
            
            matches = self.schedule_config.get('matches', [])
            match = next((m for m in matches if m.get('id') == match_id), None)
            
            if match:
                message = f"""
<b>‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—á–∞</b>

<b>–¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ:</b>
–ö–æ–º–∞–Ω–¥–∞ 1: {match.get('team1')}
–ö–æ–º–∞–Ω–¥–∞ 2: {match.get('team2')}
–î–∞—Ç–∞: {match.get('date')}
–í—Ä–µ–º—è: {match.get('time')}
–°–µ—Ä–∏—è: {match.get('series_type', 'bo1').upper()}
–†–µ–∂–∏–º: {match.get('game_mode', 'Captains Mode')}

–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–π –∫–æ–º–∞–Ω–¥—ã:
"""
                await query.edit_message_text(message, parse_mode='HTML')
                return WAITING_MATCH_TEAM1
    
    async def handle_match_team1_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í–≤–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏—è –ø–µ—Ä–≤–æ–π –∫–æ–º–∞–Ω–¥—ã"""
        team1 = update.message.text.strip()
        context.user_data['match_team1'] = team1
        
        await update.message.reply_text(
            f"<b>‚úÖ –ö–æ–º–∞–Ω–¥–∞ 1:</b> {team1}\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–π –∫–æ–º–∞–Ω–¥—ã:\n"
            f"<i>–ù–∞–ø—Ä–∏–º–µ—Ä: team asd</i>",
            parse_mode='HTML'
        )
        return WAITING_MATCH_TEAM2
    
    async def handle_match_team2_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í–≤–æ–¥ –Ω–∞–∑–≤–∞–Ω–∏—è –≤—Ç–æ—Ä–æ–π –∫–æ–º–∞–Ω–¥—ã"""
        team2 = update.message.text.strip()
        context.user_data['match_team2'] = team2
        
        team1 = context.user_data.get('match_team1', '???')
        
        await update.message.reply_text(
            f"<b>‚úÖ –ö–æ–º–∞–Ω–¥–∞ 1:</b> {team1}\n"
            f"<b>‚úÖ –ö–æ–º–∞–Ω–¥–∞ 2:</b> {team2}\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –º–∞—Ç—á–∞:\n"
            f"<i>–§–æ—Ä–º–∞—Ç: –î–î.–ú–ú.–ì–ì–ì–ì\n–ù–∞–ø—Ä–∏–º–µ—Ä: 26.10.2025</i>",
            parse_mode='HTML'
        )
        return WAITING_MATCH_DATE
    
    async def handle_match_date_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í–≤–æ–¥ –¥–∞—Ç—ã –º–∞—Ç—á–∞"""
        date_str = update.message.text.strip()
        
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞
        import re
        if not re.match(r'^\d{2}\.\d{2}\.\d{4}$', date_str):
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã!\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: <b>–î–î.–ú–ú.–ì–ì–ì–ì</b>\n"
                "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>26.10.2025</b>",
                parse_mode='HTML'
            )
            return WAITING_MATCH_DATE
        
        context.user_data['match_date'] = date_str
        
        await update.message.reply_text(
            f"<b>‚úÖ –î–∞—Ç–∞:</b> {date_str}\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è –º–∞—Ç—á–∞:\n"
            f"<i>–§–æ—Ä–º–∞—Ç: –ß–ß:–ú–ú\n–ù–∞–ø—Ä–∏–º–µ—Ä: 18:00</i>",
            parse_mode='HTML'
        )
        return WAITING_MATCH_TIME
    
    async def handle_match_time_input(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í–≤–æ–¥ –≤—Ä–µ–º–µ–Ω–∏ –º–∞—Ç—á–∞"""
        time_str = update.message.text.strip()
        
        # –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞
        import re
        if not re.match(r'^\d{1,2}:\d{2}$', time_str):
            await update.message.reply_text(
                "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏!\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: <b>–ß–ß:–ú–ú</b>\n"
                "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>18:00</b>",
                parse_mode='HTML'
            )
            return WAITING_MATCH_TIME
        
        context.user_data['match_time'] = time_str
        
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã
        keyboard = [
            [InlineKeyboardButton("‚öîÔ∏è Captains Mode", callback_data="match_mode_Captains Mode")],
            [InlineKeyboardButton("üé≤ All Pick", callback_data="match_mode_All Pick")],
            [InlineKeyboardButton("üìã Captains Draft", callback_data="match_mode_Captains Draft")],
            [InlineKeyboardButton("üéØ Mid Only", callback_data="match_mode_Mid Only")],
            [InlineKeyboardButton("ü•ä 1v1 Solo Mid", callback_data="match_mode_1v1 Solo Mid")],
        ]
        
        await update.message.reply_text(
            f"<b>‚úÖ –í—Ä–µ–º—è:</b> {time_str}\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –∏–≥—Ä—ã:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return WAITING_MATCH_GAME_MODE
    
    async def handle_match_mode_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã –¥–ª—è –º–∞—Ç—á–∞"""
        query = update.callback_query
        game_mode = query.data.replace("match_mode_", "")
        context.user_data['match_game_mode'] = game_mode
        
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É —Å–µ—Ä–∏–∏
        keyboard = [
            [InlineKeyboardButton("1Ô∏è‚É£ –û–¥–Ω–∞ –∏–≥—Ä–∞ (BO1)", callback_data="match_series_bo1")],
            [InlineKeyboardButton("2Ô∏è‚É£ –î–≤–µ –∏–≥—Ä—ã (BO2)", callback_data="match_series_bo2")],
            [InlineKeyboardButton("3Ô∏è‚É£ –î–æ 2 –ø–æ–±–µ–¥ (BO3)", callback_data="match_series_bo3")],
            [InlineKeyboardButton("5Ô∏è‚É£ –î–æ 3 –ø–æ–±–µ–¥ (BO5)", callback_data="match_series_bo5")],
        ]
        
        await query.edit_message_text(
            f"<b>‚úÖ –†–µ–∂–∏–º:</b> {game_mode}\n\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Å–µ—Ä–∏–∏:",
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return WAITING_MATCH_SERIES
    
    async def handle_match_series_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–í—ã–±–æ—Ä —Å–µ—Ä–∏–∏ –¥–ª—è –º–∞—Ç—á–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ"""
        query = update.callback_query
        series_type = query.data.replace("match_series_", "")
        context.user_data['match_series_type'] = series_type
        
        # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
        team1 = context.user_data.get('match_team1')
        team2 = context.user_data.get('match_team2')
        date = context.user_data.get('match_date')
        time_str = context.user_data.get('match_time')
        game_mode = context.user_data.get('match_game_mode')
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º
        editing_match_id = context.user_data.get('editing_match_id')
        
        if editing_match_id:
            # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –º–∞—Ç—á–∞
            matches = self.schedule_config.get('matches', [])
            for match in matches:
                if match.get('id') == editing_match_id:
                    match['team1'] = team1
                    match['team2'] = team2
                    match['date'] = date
                    match['time'] = time_str
                    match['game_mode'] = game_mode
                    match['series_type'] = series_type
                    break
            
            del context.user_data['editing_match_id']
            message = "‚úÖ <b>–ú–∞—Ç—á –æ–±–Ω–æ–≤–ª—ë–Ω!</b>\n\n"
        else:
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–∞—Ç—á–∞
            new_id = max([m.get('id', 0) for m in self.schedule_config.get('matches', [])], default=0) + 1
            
            new_match = {
                'id': new_id,
                'team1': team1,
                'team2': team2,
                'date': date,
                'time': time_str,
                'game_mode': game_mode,
                'series_type': series_type,
                'enabled': True,
                'status': 'scheduled'
            }
            
            if 'matches' not in self.schedule_config:
                self.schedule_config['matches'] = []
            
            self.schedule_config['matches'].append(new_match)
            message = "‚úÖ <b>–ú–∞—Ç—á –¥–æ–±–∞–≤–ª–µ–Ω!</b>\n\n"
        
        self.save_schedule()
        
        message += f"<b>{team1} vs {team2}</b>\n"
        message += f"üìÖ {date} ‚è∞ {time_str}\n"
        message += f"üéÆ {game_mode}\n"
        message += f"üéØ {series_type.upper()}"
        
        await query.edit_message_text(
            message,
            parse_mode='HTML',
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é", callback_data="schedule")
            ]])
        )
        
        # –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        for key in ['match_team1', 'match_team2', 'match_date', 'match_time', 'match_game_mode', 'match_series_type']:
            context.user_data.pop(key, None)
        
        return ConversationHandler.END
    
    async def handle_status(self, query):
        total = len(self.steam_accounts)
        available = len(self.get_available_accounts())
        
        message = f"""
<b>üìä –°—Ç–∞—Ç—É—Å</b>

ü§ñ –ë–æ—Ç—ã:
   –í—Å–µ–≥–æ: {total}
   üíö –°–≤–æ–±–æ–¥–Ω—ã—Ö: {available}
   üî¥ –ó–∞–Ω—è—Ç—ã—Ö: {total - available}

üéØ –õ–æ–±–±–∏: {len(self.active_lobbies)}

‚öôÔ∏è –†–µ–∂–∏–º: üîó –†–ï–ê–õ–¨–ù–û–ï —Å–æ–∑–¥–∞–Ω–∏–µ
        """
        try:
            await query.edit_message_text(
                message,
                parse_mode='HTML',
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="status"),
                    InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")
                ]])
            )
        except:
            pass
    
    async def handle_back_to_main(self, query):
        text = self.get_welcome_text()
        try:
            await query.edit_message_text(text, parse_mode='HTML', reply_markup=self.get_main_keyboard())
        except:
            pass
    
    async def cancel(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ", reply_markup=self.get_main_keyboard())
        return ConversationHandler.END
    
    # ==================== –ü–õ–ê–ù–ò–†–û–í–©–ò–ö ====================
    
    def setup_scheduler(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏"""
        if self.scheduler is None:
            from apscheduler.schedulers.asyncio import AsyncIOScheduler
            self.scheduler = AsyncIOScheduler(timezone=self.schedule_config.get('timezone', 'Europe/Moscow'))
        
        # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏
        self.scheduler.remove_all_jobs()
        
        # –ï—Å–ª–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤—ã–∫–ª—é—á–µ–Ω–æ - –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏
        if not self.schedule_config.get('enabled', False):
            logger.info("üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤—ã–∫–ª—é—á–µ–Ω–æ, –∑–∞–¥–∞—á–∏ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã")
            return
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –º–∞—Ç—á–∞
        matches = self.schedule_config.get('matches', [])
        active_matches = [m for m in matches if m.get('enabled', False)]
        
        for match in active_matches:
            try:
                # –ü–∞—Ä—Å–∏–º –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è
                date_str = match.get('date')  # "26.10.2025"
                time_str = match.get('time')  # "18:00"
                
                day, month, year = map(int, date_str.split('.'))
                hour, minute = map(int, time_str.split(':'))
                
                # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è
                run_date = datetime(year, month, day, hour, minute)
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á—É
                self.scheduler.add_job(
                    self.execute_scheduled_match,
                    'date',
                    run_date=run_date,
                    args=[match],
                    id=f"match_{match['id']}",
                    replace_existing=True
                )
                
                logger.info(f"üìÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞: {match['team1']} vs {match['team2']} –Ω–∞ {date_str} {time_str}")
            
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –¥–ª—è –º–∞—Ç—á–∞ {match.get('id')}: {e}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –µ—Å–ª–∏ –µ—Å—Ç—å –∑–∞–¥–∞—á–∏ (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ event loop —É–∂–µ –∑–∞–ø—É—â–µ–Ω)
        if active_matches:
            if not self.scheduler.running:
                try:
                    self.scheduler.start()
                    logger.info(f"‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω, –∑–∞–¥–∞—á: {len(active_matches)}")
                except RuntimeError:
                    # Event loop –µ—â–µ –Ω–µ –∑–∞–ø—É—â–µ–Ω, –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –ø–æ–∑–∂–µ
                    logger.info(f"üìÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –±—É–¥–µ—Ç –∑–∞–ø—É—â–µ–Ω –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ event loop, –∑–∞–¥–∞—á: {len(active_matches)}")
        else:
            logger.info("üìÖ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–∞—Ç—á–µ–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏")
    
    async def execute_scheduled_match(self, match: dict):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ –¥–ª—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Ç—á–∞"""
        try:
            team1 = match.get('team1')
            team2 = match.get('team2')
            game_mode = match.get('game_mode', 'Captains Mode')
            series_type = match.get('series_type', 'bo1')
            
            lobby_name = f"{team1} vs {team2}"
            
            logger.info(f"üéÆ –°–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é: {lobby_name}")
            
            # –ò—â–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç
            available_accounts = self.get_available_accounts()
            
            if not available_accounts:
                logger.error(f"‚ùå –ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏: {lobby_name}")
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
                if self.notification_chat_id:
                    message = f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é!</b>\n\n"
                    message += f"<b>{lobby_name}</b>\n"
                    message += f"–ü—Ä–∏—á–∏–Ω–∞: –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤"
                    
                    send_kwargs = {
                        'chat_id': self.notification_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    
                    if self.notification_thread_id:
                        send_kwargs['message_thread_id'] = self.notification_thread_id
                    
                    await self.telegram_app.bot.send_message(**send_kwargs)
                
                return
            
            # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π —Å–≤–æ–±–æ–¥–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç
            account = available_accounts[0]
            account.is_busy = True
            
            # –°–æ–∑–¥–∞–µ–º —Ñ–µ–π–∫–æ–≤—ã–π status_msg –¥–ª—è create_single_real_lobby
            class FakeMessage:
                async def edit_text(self, *args, **kwargs):
                    pass
            
            fake_msg = FakeMessage()
            
            # –°–æ–∑–¥–∞–µ–º –ª–æ–±–±–∏
            lobby_info = await self.create_single_real_lobby(
                account,
                fake_msg,
                game_mode=game_mode,
                series_type=series_type,
                lobby_name=lobby_name
            )
            
            if lobby_info:
                logger.info(f"‚úÖ –õ–æ–±–±–∏ —Å–æ–∑–¥–∞–Ω–æ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é: {lobby_name}")
                
                # –ú–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –º–∞—Ç—á–∞ –Ω–∞ "active"
                match['status'] = 'active'
                self.save_schedule()
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                if self.notification_chat_id:
                    message = f"<b>{lobby_name}</b>\n\n"
                    message += f"üîí –ü–∞—Ä–æ–ª—å: <code>{lobby_info.password}</code>\n"
                    message += f"üéÆ –†–µ–∂–∏–º: {game_mode}\n"
                    message += f"üéØ –°–µ—Ä–∏—è: {series_type.upper()}"
                    
                    send_kwargs = {
                        'chat_id': self.notification_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    
                    if self.notification_thread_id:
                        send_kwargs['message_thread_id'] = self.notification_thread_id
                    
                    await self.telegram_app.bot.send_message(**send_kwargs)
            else:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é: {lobby_name}")
                account.is_busy = False
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
                if self.notification_chat_id:
                    message = f"‚ùå <b>–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é!</b>\n\n"
                    message += f"<b>{lobby_name}</b>\n"
                    message += f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π"
                    
                    send_kwargs = {
                        'chat_id': self.notification_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    
                    if self.notification_thread_id:
                        send_kwargs['message_thread_id'] = self.notification_thread_id
                    
                    await self.telegram_app.bot.send_message(**send_kwargs)
        
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Ç—á–∞: {e}", exc_info=True)
    
    # ==================== SETUP ====================
    
    async def post_init(self, application: Application) -> None:
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Application"""
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –µ—Å–ª–∏ –æ–Ω –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏ –µ—Å—Ç—å –∑–∞–¥–∞—á–∏
        if self.scheduler and not self.scheduler.running:
            if self.scheduler.get_jobs():
                self.scheduler.start()
                logger.info(f"‚úÖ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω –≤ post_init, –∑–∞–¥–∞—á: {len(self.scheduler.get_jobs())}")
    
    def setup_telegram_bot(self):
        self.telegram_app = Application.builder().token(self.telegram_token).post_init(self.post_init).build()
        
        # Handler —Å–æ–∑–¥–∞–Ω–∏—è –ª–æ–±–±–∏ —Å –≤—ã–±–æ—Ä–æ–º –±–æ—Ç–æ–≤, —Ä–µ–∂–∏–º–∞ –∏ —Å–µ—Ä–∏–∏
        create_handler = ConversationHandler(
            entry_points=[CallbackQueryHandler(self.handle_create_lobby_request, pattern="^create_lobby$")],
            states={
                WAITING_SELECT_BOTS: [
                    CallbackQueryHandler(self.handle_toggle_bot_selection, pattern="^toggle_bot_"),
                    CallbackQueryHandler(self.handle_confirm_bot_selection, pattern="^confirm_bot_selection$"),
                ],
                WAITING_GAME_MODE: [
                    CallbackQueryHandler(self.handle_game_mode_selection, pattern="^mode_"),
                ],
                WAITING_SERIES_TYPE: [
                    CallbackQueryHandler(self.handle_series_selection, pattern="^series_"),
                ],
            },
            fallbacks=[CommandHandler('cancel', self.cancel)],
            allow_reentry=True
        )
        
        # Handler –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–∞
        add_bot_handler = ConversationHandler(
            entry_points=[CallbackQueryHandler(self.handle_add_bot_request, pattern="^add_bot$")],
            states={
                WAITING_ACCOUNT_DATA: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_account_data_input)],
            },
            fallbacks=[CommandHandler('cancel', self.cancel)],
            allow_reentry=True
        )
        
        # Handler —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞
        edit_bot_handler = ConversationHandler(
            entry_points=[CallbackQueryHandler(self.handle_edit_bot_request, pattern="^edit_bot_")],
            states={
                WAITING_EDIT_BOT_DATA: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_edit_bot_data_input)],
            },
            fallbacks=[CommandHandler('cancel', self.cancel)],
            allow_reentry=True
        )
        
        # Handler —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–∞—Ç—á–∞–º–∏ (–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
        match_handler = ConversationHandler(
            entry_points=[
                CallbackQueryHandler(self.handle_match_action, pattern="^match_add$"),
                CallbackQueryHandler(self.handle_match_action, pattern="^match_edit_"),
            ],
            states={
                WAITING_MATCH_TEAM1: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_match_team1_input)],
                WAITING_MATCH_TEAM2: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_match_team2_input)],
                WAITING_MATCH_DATE: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_match_date_input)],
                WAITING_MATCH_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_match_time_input)],
                WAITING_MATCH_GAME_MODE: [CallbackQueryHandler(self.handle_match_mode_selection, pattern="^match_mode_")],
                WAITING_MATCH_SERIES: [CallbackQueryHandler(self.handle_match_series_selection, pattern="^match_series_")],
            },
            fallbacks=[CommandHandler('cancel', self.cancel)],
            allow_reentry=True
        )
        
        self.telegram_app.add_handler(CommandHandler("start", self.cmd_start))
        self.telegram_app.add_handler(create_handler)
        self.telegram_app.add_handler(add_bot_handler)
        self.telegram_app.add_handler(edit_bot_handler)
        self.telegram_app.add_handler(match_handler)
        self.telegram_app.add_handler(CallbackQueryHandler(self.button_callback))
    
    def start_sync(self):
        logger.info("=" * 50)
        logger.info("üöÄ REAL Dota 2 Lobby Bot v2")
        logger.info("=" * 50)
        
        if not self.telegram_token:
            logger.error("‚ùå –ù–µ—Ç TELEGRAM_BOT_TOKEN")
            return
        
        logger.info("–ù–∞—Å—Ç—Ä–æ–π–∫–∞...")
        self.setup_telegram_bot()
        self.setup_scheduler()
        
        logger.info(f"–ê–∫–∫–∞—É–Ω—Ç–æ–≤: {len(self.steam_accounts)}")
        logger.info("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
        logger.info("üîó –†–µ–∂–∏–º: –†–ï–ê–õ–¨–ù–û–ï —Å–æ–∑–¥–∞–Ω–∏–µ –ª–æ–±–±–∏ v2")
        logger.info("=" * 50)
        
        self.telegram_app.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)


def main():
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ multiprocessing –¥–ª—è Windows/Linux
    try:
        multiprocessing.set_start_method('spawn', force=True)
    except RuntimeError:
        pass  # –£–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
    
    bot = RealDota2BotV2()
    try:
        bot.start_sync()
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª shutdown –≤—Å–µ–º –ø—Ä–æ—Ü–µ—Å—Å–∞–º
        for username in list(bot.shutdown_events.keys()):
            if username in bot.shutdown_events:
                logger.info(f"–û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª shutdown –¥–ª—è {username}...")
                bot.shutdown_events[username].set()
        
        # –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (–º–∞–∫—Å 25 —Å–µ–∫—É–Ω–¥)
        logger.info("–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (–º–∞–∫—Å 25 —Å–µ–∫—É–Ω–¥)...")
        for username, process in list(bot.active_processes.items()):
            try:
                if process.is_alive():
                    process.join(timeout=25)
                    
                    if process.is_alive():
                        logger.warning(f"–ü—Ä–æ—Ü–µ—Å—Å {username} –Ω–µ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ...")
                        process.terminate()
                        process.join(timeout=2)
                    
                    if process.is_alive():
                        logger.warning(f"–£–±–∏–≤–∞–µ–º {username}...")
                        process.kill()
                        process.join()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ {username}: {e}")
        
        # –£–ë–ò–í–ê–ï–ú –í–°–ï –û–°–¢–ê–í–®–ò–ï–°–Ø –ü–†–û–¶–ï–°–°–´ Steam/Dota/Python
        logger.info("üî™ –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...")
        import subprocess
        try:
            subprocess.run(['pkill', '-9', '-f', 'steam'], stderr=subprocess.DEVNULL)
            subprocess.run(['pkill', '-9', '-f', 'dota'], stderr=subprocess.DEVNULL)
        except:
            pass
        
        logger.info("‚úÖ –í—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞: {e}", exc_info=True)


if __name__ == "__main__":
    main()

